namespace: atb

imagePullSecrets: []

broker:
  enabled: true
  name: broker
  serviceAccount:
    create: true
    # If empty, defaults to "atb-broker".
    name: ""
  image:
    repository: ghcr.io/mauriciomferz/atb-broker
    tag: "0.1.0"
    pullPolicy: IfNotPresent
  replicas: 1
  # Autoscaling configuration
  autoscaling:
    enabled: false
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  # Pod Disruption Budget
  podDisruptionBudget:
    enabled: false
    minAvailable: 1
    # maxUnavailable: 1
  tls:
    # "secret" = mount a Kubernetes TLS secret and run file-based TLS
    # "spiffe" = run secret-less mTLS using SPIFFE Workload API (requires mounting the Workload API socket)
    mode: secret
    # Only used when mode=secret. If empty, defaults to "<release>-broker-tls".
    secretName: ""
  service:
    type: ClusterIP
    mtlsPort: 8443
    httpPort: 8080
  env:
    UPSTREAM_URL: "http://upstream.default.svc.cluster.local:9000"
    OPA_DECISION_URL: "http://{{ .Release.Name }}-opa.{{ .Values.namespace }}.svc.cluster.local:8181/v1/data/atb/poa/decision"
    POA_MAX_TTL_SECONDS: "300"
    # PoA verification: when empty and AgentAuth is enabled, the broker chart defaults this to the in-cluster AgentAuth JWKS endpoint.
    POA_JWKS_URL: ""
    POA_JWKS_CACHE_SECONDS: "300"
    POA_VERIFY_PUBKEY_PEM: ""
    # Audit sink (SIEM/Log Analytics) - leave empty to use stdout only
    AUDIT_SINK_URL: ""
    AUDIT_SINK_BATCH_SIZE: "100"
    AUDIT_SINK_FLUSH_SECONDS: "5"
    # Immutable (WORM) audit storage for compliance / tamper-evidence
    # Supports: Azure Blob (immutability policy), AWS S3 (Object Lock), generic HTTP
    AUDIT_IMMUTABLE_URL: ""
    AUDIT_IMMUTABLE_BACKEND: "azure"  # "azure", "s3", or "http"
    AUDIT_RETENTION_DAYS: "2555"      # ~7 years default for compliance
  secrets:
    # If set, these override the corresponding plaintext env vars above.
    poaJwksUrl:
      name: ""
      key: "poa_jwks_url"
    poaVerifyPubkeyPem:
      name: ""
      key: "poa_verify_pubkey_pem"
    # Audit sink auth (e.g., "Bearer <token>" or "SharedKey <workspace>:<sig>")
    auditSinkAuth:
      name: ""
      key: "audit_sink_auth"
    # Immutable storage auth (SAS token, AWS sig, or Bearer token)
    immutableStorageAuth:
      name: ""
      key: "immutable_storage_auth"
    # Guardrails auth (e.g., "Bearer <token>" or API key for Azure AI Content Safety)
    guardrailsAuth:
      name: ""
      key: "guardrails_auth"
  # Semantic guardrails / content safety service
  guardrails:
    # External guardrails service URL (e.g., Azure AI Content Safety endpoint)
    # Leave empty to use local pattern matching only
    url: ""
  # SPIFFE JWT-SVID for external API authentication
  jwtSvid:
    # Cache TTL in seconds for JWT-SVIDs (default 30s)
    cacheTTLSeconds: "30"
  # SPIFFE Federation - trust bundles from federated domains
  federation:
    # ConfigMap name containing federation.json with trust domains
    configMapName: ""
    # Refresh interval for federation bundles (seconds)
    refreshSeconds: "300"
  # Platform â†” SPIFFE identity binding
  platformBinding:
    # Mode: "none" (disabled), "exact" (sub == SPIFFE ID), "prefix" (sub in path), "mapping" (lookup table)
    mode: "none"
    # ConfigMap name containing platform-spiffe-mapping.json (for "mapping" mode)
    mappingConfigMapName: ""
  # Connector configuration for multi-backend routing
  connectors:
    # If enabled, provide config inline or via ConfigMap
    enabled: false
    # ConfigMap name containing connectors.json (mutually exclusive with inline)
    configMapName: ""
    # Inline connector config (used if configMapName is empty)
    inline: |
      {
        "default_connector": "",
        "connectors": []
      }
  resources: {}
  securityContext:
    runAsNonRoot: true
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true

pep:
  enabled: false

opa:
  enabled: true
  name: opa
  serviceAccount:
    create: true
    # If empty, defaults to "atb-opa".
    name: ""
  image:
    repository: openpolicyagent/opa
    tag: "latest"
    pullPolicy: IfNotPresent
  # v0Compatible is deprecated - ATB uses Rego v1 syntax (OPA 1.0+ default)
  # v0Compatible: false  # Not needed, Rego v1 is the default
  replicas: 1
  # Pod Disruption Budget
  podDisruptionBudget:
    enabled: false
    minAvailable: 1
    # maxUnavailable: 1
  service:
    type: ClusterIP
    port: 8181
  resources: {}

agentauth:
  enabled: true
  name: agentauth
  serviceAccount:
    create: true
    # If empty, defaults to "atb-agentauth".
    name: ""
  image:
    repository: ghcr.io/mauriciomferz/atb-agentauth
    tag: "0.1.0"
    pullPolicy: IfNotPresent
  replicas: 1
  # Autoscaling configuration
  autoscaling:
    enabled: false
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
  # Pod Disruption Budget
  podDisruptionBudget:
    enabled: false
    minAvailable: 1
    # maxUnavailable: 1
  service:
    type: ClusterIP
    port: 9090
  env:
    POA_ISSUER: "atb-agentauth"
    POA_TTL_SECONDS: "300"
    CHALLENGE_TTL_SECONDS: "300"
    # Optional: require this header for approvals (simulates MFA/approval gateway)
    APPROVAL_SHARED_SECRET: ""
    # REMOVED: POA_SIGNING_ED25519_PRIVKEY_PEM must NOT be supplied in values.yaml.
    # Always provide the signing key via agentauth.secrets.signingKey (Kubernetes Secret).
  secrets:
    # If set, these override the corresponding plaintext env vars above.
    approvalSharedSecret:
      name: ""
      key: "approval_shared_secret"
    # REQUIRED when agentauth.enabled=true: the Ed25519 signing key (PKCS8 PEM) must be
    # sourced from a Kubernetes Secret.
    signingKey:
      name: ""  # <-- set this to your Secret name
      key: "ed25519_privkey_pem"
  resources: {}

policy:
  regoConfigMapName: atb-opa-policy
  regoKey: poa.rego

observability:
  prometheus:
    enabled: false
    serviceMonitor:
      enabled: false
      interval: 30s
      scrapeTimeout: 10s
    # PrometheusRule for SLO alerts (requires prometheus-operator CRDs)
    rules:
      enabled: false
      # Labels to add to PrometheusRule for Prometheus selector
      additionalLabels: {}
      # SLO target for broker availability (0.999 = 99.9%)
      brokerAvailabilitySLO: 0.999
  otel:
    enabled: false
    endpoint: "http://otel-collector.monitoring.svc.cluster.local:4318"
    sampler: "parentbased_traceidratio"
    samplerArg: "0.1"

csi:
  enabled: false
  driver: "csi.spiffe.io"
  mountPath: "/spire-agent-socket"
  socketFile: "workload-api.sock"

# Ingress configuration
ingress:
  enabled: false
  className: "nginx"
  annotations: {}
    # kubernetes.io/tls-acme: "true"
    # nginx.ingress.kubernetes.io/ssl-redirect: "true"
  hosts:
    - host: atb.example.com
  tls: []
    # - secretName: atb-tls
    #   hosts:
    #     - atb.example.com

# Network Policy configuration
networkPolicy:
  enabled: false
  broker:
    allowExternalEgress: true

# Dashboard configuration
dashboard:
  enabled: false
  replicaCount: 1
  image:
    repository: ghcr.io/mauriciomferz/atb-dashboard
    tag: "0.1.0"
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 80
  config:
    apiUrl: "http://atb-broker:8080"
    wsUrl: "ws://atb-broker:8080/ws"
  resources:
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 50m
      memory: 64Mi
  nodeSelector: {}
  affinity: {}
  tolerations: []
