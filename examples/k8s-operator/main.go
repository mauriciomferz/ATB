package k8soperator


























































































































































































































































































































































































































































































































































































































































































}	}		log.Fatalf("Operator error: %v", err)	if err := operator.Run(ctx); err != nil {	}()		cancel()		log.Println("Received shutdown signal")		<-sigChan	go func() {	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)	sigChan := make(chan os.Signal, 1)	// Handle shutdown gracefully	defer cancel()	ctx, cancel := context.WithCancel(context.Background())	operator := NewOperator(k8sClient, atbClient, namespace)	// Create and run operator	atbClient := NewATBClient(atbURL, tlsConfig)	}		InsecureSkipVerify: os.Getenv("ATB_INSECURE") == "true",		// In production, load from mounted secrets	tlsConfig := &tls.Config{	// Setup ATB client with mTLS	}		log.Fatalf("Failed to create k8s client: %v", err)	if err != nil {	k8sClient, err := dynamic.NewForConfig(config)	}		}			log.Fatalf("Failed to create k8s config: %v", err)		if err != nil {		config, err = clientcmd.BuildConfigFromFlags("", kubeconfig)		}			kubeconfig = os.Getenv("HOME") + "/.kube/config"		if kubeconfig == "" {		kubeconfig := os.Getenv("KUBECONFIG")		// Fallback to kubeconfig for local development	if err != nil {	config, err := rest.InClusterConfig()	// Setup K8s client	}		namespace = "default"	if namespace == "" {	namespace := os.Getenv("WATCH_NAMESPACE")	}		atbURL = "https://atb-broker.default.svc:8443"	if atbURL == "" {	atbURL := os.Getenv("ATB_BROKER_URL")	// Configurationfunc main() {}	}		return schema.GroupVersionResource{Group: "", Version: "v1", Resource: kind}	default:		return schema.GroupVersionResource{Group: "", Version: "v1", Resource: "services"}	case "Service":		return schema.GroupVersionResource{Group: "", Version: "v1", Resource: "secrets"}	case "Secret":		return schema.GroupVersionResource{Group: "", Version: "v1", Resource: "configmaps"}	case "ConfigMap":		return schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "daemonsets"}	case "DaemonSet":		return schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "statefulsets"}	case "StatefulSet":		return schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "deployments"}	case "Deployment":	switch kind {	// Map kinds to GVRsfunc (r *ActionRouter) getGVR(kind string) schema.GroupVersionResource {}	return err		Patch(ctx, task.Spec.Target.Name, "application/json-patch+json", []byte(patchData), metav1.PatchOptions{})	_, err := r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	gvr := r.getGVR(task.Spec.Target.Kind)	}		return fmt.Errorf("missing or invalid 'patch' in payload")	if !ok {	patchData, ok := task.Spec.Payload["patch"].(string)	// Apply a JSON patchfunc (r *ActionRouter) executePatch(ctx context.Context, task *AgentTask) error {}	return err		Update(ctx, obj, metav1.UpdateOptions{})	_, err = r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	}		return fmt.Errorf("set annotations: %w", err)	if err := unstructured.SetNestedStringMap(obj.Object, annotations, "metadata", "annotations"); err != nil {	annotations["atb.siemens.com/rollback-to-revision"] = fmt.Sprintf("%.0f", revision)	}		annotations = make(map[string]string)	if annotations == nil {	annotations, _, _ := unstructured.NestedStringMap(obj.Object, "metadata", "annotations")	}		return fmt.Errorf("get resource: %w", err)	if err != nil {		Get(ctx, task.Spec.Target.Name, metav1.GetOptions{})	obj, err := r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	gvr := r.getGVR(task.Spec.Target.Kind)	// In production, you'd use the apps/v1 rollback API	// For simplicity, we annotate the deployment with the target revision	}		return fmt.Errorf("missing or invalid 'revision' in payload")	if !ok {	revision, ok := task.Spec.Payload["revision"].(float64)	// Rollback to a previous revisionfunc (r *ActionRouter) executeRollback(ctx context.Context, task *AgentTask) error {}	return err	}			Create(ctx, obj, metav1.CreateOptions{})		_, err = r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	if err != nil {		Update(ctx, obj, metav1.UpdateOptions{})	_, err := r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	// Try update first, then create	gvr := r.getGVR(task.Spec.Target.Kind)	obj := &unstructured.Unstructured{Object: manifest}	}		return fmt.Errorf("missing or invalid 'manifest' in payload")	if !ok {	manifest, ok := task.Spec.Payload["manifest"].(map[string]interface{})	// Create or update a deployment from payloadfunc (r *ActionRouter) executeDeploy(ctx context.Context, task *AgentTask) error {}	return err		Update(ctx, obj, metav1.UpdateOptions{})	_, err = r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	}		return fmt.Errorf("set data: %w", err)	if err := unstructured.SetNestedStringMap(obj.Object, existingData, "data"); err != nil {	}		}			existingData[k] = str		if str, ok := v.(string); ok {	for k, v := range data {	}		existingData = make(map[string]string)	if existingData == nil {	existingData, _, _ := unstructured.NestedStringMap(obj.Object, "data")	// Merge data	}		return fmt.Errorf("get resource: %w", err)	if err != nil {		Get(ctx, task.Spec.Target.Name, metav1.GetOptions{})	obj, err := r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	gvr := r.getGVR(task.Spec.Target.Kind)	}		return fmt.Errorf("missing or invalid 'data' in payload")	if !ok {	data, ok := task.Spec.Payload["data"].(map[string]interface{})	// Update ConfigMap or Secretfunc (r *ActionRouter) executeUpdateConfig(ctx context.Context, task *AgentTask) error {}	return err		Update(ctx, obj, metav1.UpdateOptions{})	_, err = r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	}		return fmt.Errorf("set annotations: %w", err)	if err := unstructured.SetNestedStringMap(obj.Object, annotations, "spec", "template", "metadata", "annotations"); err != nil {	annotations["kubectl.kubernetes.io/restartedAt"] = time.Now().Format(time.RFC3339)	}		annotations = make(map[string]string)	if annotations == nil {	annotations, _, _ := unstructured.NestedStringMap(obj.Object, "spec", "template", "metadata", "annotations")	// Add restart annotation to trigger rolling restart	}		return fmt.Errorf("get resource: %w", err)	if err != nil {		Get(ctx, task.Spec.Target.Name, metav1.GetOptions{})	obj, err := r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	gvr := r.getGVR(task.Spec.Target.Kind)func (r *ActionRouter) executeRestart(ctx context.Context, task *AgentTask) error {}	return err		Update(ctx, obj, metav1.UpdateOptions{})	_, err = r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	}		return fmt.Errorf("set replicas: %w", err)	if err := unstructured.SetNestedField(obj.Object, int64(replicas), "spec", "replicas"); err != nil {	// Update replicas	}		return fmt.Errorf("get resource: %w", err)	if err != nil {		Get(ctx, task.Spec.Target.Name, metav1.GetOptions{})	obj, err := r.k8sClient.Resource(gvr).Namespace(task.Spec.Target.Namespace).	// Get current resource		gvr := r.getGVR(task.Spec.Target.Kind)	}		return fmt.Errorf("missing or invalid 'replicas' in payload")	if !ok {	replicas, ok := task.Spec.Payload["replicas"].(float64)func (r *ActionRouter) executeScale(ctx context.Context, task *AgentTask) error {}	}		return fmt.Errorf("unsupported action: %s", task.Spec.Action)	default:		return r.executePatch(ctx, task)	case ActionPatchResource:		return r.executeRollback(ctx, task)	case ActionRollback:		return r.executeDeploy(ctx, task)	case ActionDeploy:		return r.executeUpdateConfig(ctx, task)	case ActionUpdateConfig:		return r.executeRestart(ctx, task)	case ActionRestart:		return r.executeScale(ctx, task)	case ActionScale:	switch task.Spec.Action {func (r *ActionRouter) Execute(ctx context.Context, task *AgentTask) error {}	return &ActionRouter{k8sClient: k8sClient}func NewActionRouter(k8sClient dynamic.Interface) *ActionRouter {}	k8sClient dynamic.Interfacetype ActionRouter struct {// ActionRouter handles execution of different K8s actions}	m.tasksFailed++	m.tasksProcessed++	defer m.mu.Unlock()	m.mu.Lock()func (m *OperatorMetrics) recordFailed() {}	m.tasksDenied++	m.tasksProcessed++	defer m.mu.Unlock()	m.mu.Lock()func (m *OperatorMetrics) recordDenied() {}	m.avgProcessingTime = (m.avgProcessingTime*float64(m.tasksProcessed-1) + duration.Seconds()) / float64(m.tasksProcessed)	// Simple moving average	m.tasksAllowed++	m.tasksProcessed++	defer m.mu.Unlock()	m.mu.Lock()func (m *OperatorMetrics) recordAllowed(duration time.Duration) {}	}		log.Printf("Failed to update status: %v", err)	if err != nil {		UpdateStatus(ctx, obj, metav1.UpdateOptions{})	_, err := o.k8sClient.Resource(o.taskGVR).Namespace(o.namespace).	obj.Object["status"] = status	}		status["finishedAt"] = time.Now().Format(time.RFC3339)	if phase == "Completed" || phase == "Failed" || phase == "Denied" {	}		status["startedAt"] = time.Now().Format(time.RFC3339)	if phase == "Processing" || phase == "Executing" {	}		}			"reason":   atbResult.Reason,			"riskTier": atbResult.RiskTier,			"allowed":  atbResult.Allowed,		status["atbResult"] = map[string]interface{}{	if atbResult != nil {	}		"message": message,		"phase":   phase,	status := map[string]interface{}{func (o *Operator) updateStatus(ctx context.Context, obj *unstructured.Unstructured, phase, message string, atbResult *ATBResult) {}	return o.actionRouter.Execute(ctx, task)func (o *Operator) executeAction(ctx context.Context, task *AgentTask) error {}	return fmt.Sprintf("k8s.%s.%s", target.Kind, action)	// Format: k8s.<kind>.<action>	// Map K8s actions to ATB action formatfunc (o *Operator) mapToATBAction(action AgentAction, target ResourceTarget) string {}	o.metrics.recordAllowed(duration)	o.updateStatus(ctx, obj, "Completed", "Action executed successfully", atbResult)	log.Printf("Task %s completed successfully in %v", taskName, duration)	duration := time.Since(start)	// Success	}		return		o.metrics.recordFailed()		o.updateStatus(ctx, obj, "Failed", fmt.Sprintf("Execution error: %v", err), atbResult)		log.Printf("Execution error for task %s: %v", taskName, err)	if err := o.executeAction(ctx, task); err != nil {	// Execute the action	o.updateStatus(ctx, obj, "Executing", "Executing action", atbResult)	log.Printf("Task %s authorized by ATB (risk tier: %s)", taskName, decision.RiskTier)	}		return		o.metrics.recordDenied()		o.updateStatus(ctx, obj, "Denied", decision.Reason, atbResult)			taskName, decision.Reason, decision.RiskTier)		log.Printf("Task %s denied by ATB: %s (risk tier: %s)",	if !decision.Allowed {	}		RequestID: decision.RequestID,		Reason:    decision.Reason,		RiskTier:  decision.RiskTier,		Allowed:   decision.Allowed,	atbResult := &ATBResult{	}		return		o.metrics.recordFailed()		o.updateStatus(ctx, obj, "Failed", fmt.Sprintf("ATB error: %v", err), nil)		log.Printf("ATB error for task %s: %v", taskName, err)	if err != nil {	decision, err := o.atbClient.Decide(ctx, atbAction, task.Spec.PoAToken)	// Call ATB for authorization	atbAction := o.mapToATBAction(task.Spec.Action, task.Spec.Target)	// Map K8s action to ATB action	o.updateStatus(ctx, obj, "Processing", "Authorizing with ATB", nil)	// Update status to Processing		taskName, task.Spec.Action, task.Spec.Target.Namespace, task.Spec.Target.Name)	log.Printf("Processing AgentTask: %s (action: %s, target: %s/%s)",	taskName := task.Name	start := time.Now()func (o *Operator) processTask(ctx context.Context, obj *unstructured.Unstructured, task *AgentTask) {}	return &task, nil	}		return nil, err	if err := json.Unmarshal(data, &task); err != nil {	var task AgentTask	}		return nil, err	if err != nil {	data, err := obj.MarshalJSON()func (o *Operator) parseAgentTask(obj *unstructured.Unstructured) (*AgentTask, error) {}	go o.processTask(ctx, obj, task)	// Process the task	}		return	if task.Status.Phase != "" && task.Status.Phase != "Pending" {	// Skip if already processed	}		return		log.Printf("Parse task error: %v", err)	if err != nil {	task, err := o.parseAgentTask(obj)	// Parse the AgentTask	}		return		log.Printf("Unexpected object type: %T", event.Object)	if !ok {	obj, ok := event.Object.(*unstructured.Unstructured)	}		return	if event.Type != watch.Added && event.Type != watch.Modified {func (o *Operator) handleEvent(ctx context.Context, event watch.Event) {}	}		}			o.handleEvent(ctx, event)			}				continue				}					return fmt.Errorf("restart watch: %w", err)				if err != nil {				watcher, err = o.k8sClient.Resource(o.taskGVR).Namespace(o.namespace).Watch(ctx, metav1.ListOptions{})				log.Println("Watcher closed, restarting...")				// Watcher closed, restart			if !ok {		case event, ok := <-watcher.ResultChan():			return nil			log.Println("Operator shutting down...")		case <-ctx.Done():		select {	for {	log.Println("Watching for AgentTask resources...")	defer watcher.Stop()	}		return fmt.Errorf("watch AgentTasks: %w", err)	if err != nil {	watcher, err := o.k8sClient.Resource(o.taskGVR).Namespace(o.namespace).Watch(ctx, metav1.ListOptions{})	// Watch for AgentTask resources	log.Printf("Starting ATB Kubernetes Operator in namespace: %s", o.namespace)func (o *Operator) Run(ctx context.Context) error {// Run starts the operator control loop}	}		actionRouter: NewActionRouter(k8sClient),		metrics:      &OperatorMetrics{},		},			Resource: "agenttasks",			Version:  ATBVersion,			Group:    ATBGroup,		taskGVR: schema.GroupVersionResource{		namespace: namespace,		atbClient: atbClient,		k8sClient: k8sClient,	return &Operator{func NewOperator(k8sClient dynamic.Interface, atbClient *ATBClient, namespace string) *Operator {}	avgProcessingTime float64	tasksFailed       int64	tasksDenied       int64	tasksAllowed      int64	tasksProcessed    int64	mu                sync.RWMutextype OperatorMetrics struct {}	actionRouter *ActionRouter	metrics      *OperatorMetrics	taskGVR      schema.GroupVersionResource	namespace    string	atbClient    *ATBClient	k8sClient    dynamic.Interfacetype Operator struct {// Operator manages AgentTask resources}	return n, nil	r.pos += n	n = copy(p, r.data[r.pos:])	}		return 0, io.EOF	if r.pos >= len(r.data) {func (r *jsonBytesReader) Read(p []byte) (n int, err error) {}	pos  int	data []bytetype jsonBytesReader struct {}	return &jsonBytesReader{data: data}func jsonReader(data []byte) io.Reader {}	return &result, nil	}		return nil, fmt.Errorf("parse response: %w", err)	if err := json.Unmarshal(body, &result); err != nil {	var result ATBDecisionResponse	}		return nil, fmt.Errorf("ATB error %d: %s", resp.StatusCode, string(body))	if resp.StatusCode != http.StatusOK {	body, _ := io.ReadAll(resp.Body)	defer resp.Body.Close()	}		return nil, fmt.Errorf("ATB request failed: %w", err)	if err != nil {	resp, err := c.httpClient.Do(req)	req.Header.Set("Content-Type", "application/json")	}		return nil, fmt.Errorf("create request: %w", err)	if err != nil {		io.NopCloser(jsonReader(reqBody)))	req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL+"/api/v1/decide", 	})		Token:  token,		Action: action,	reqBody, _ := json.Marshal(ATBDecisionRequest{func (c *ATBClient) Decide(ctx context.Context, action, token string) (*ATBDecisionResponse, error) {}	Metadata  interface{} `json:"metadata,omitempty"`	RequestID string      `json:"request_id"`	Reason    string      `json:"reason,omitempty"`	RiskTier  string      `json:"risk_tier"`	Allowed   bool        `json:"allowed"`type ATBDecisionResponse struct {}	Token  string `json:"token"`	Action string `json:"action"`type ATBDecisionRequest struct {}	}		},			},				TLSClientConfig: tlsConfig,			Transport: &http.Transport{			Timeout: 30 * time.Second,		httpClient: &http.Client{		baseURL: baseURL,	return &ATBClient{func NewATBClient(baseURL string, tlsConfig *tls.Config) *ATBClient {}	httpClient *http.Client	baseURL    stringtype ATBClient struct {// ATBClient handles communication with ATB Broker}	EvaluateMs int    `json:"evaluateMs,omitempty"`	RequestID  string `json:"requestId,omitempty"`	Reason     string `json:"reason,omitempty"`	RiskTier   string `json:"riskTier,omitempty"`	Allowed    bool   `json:"allowed"`type ATBResult struct {}	ATBResult  *ATBResult  `json:"atbResult,omitempty"`	FinishedAt metav1.Time `json:"finishedAt,omitempty"`	StartedAt  metav1.Time `json:"startedAt,omitempty"`	Message    string      `json:"message,omitempty"`	Phase      string      `json:"phase"`type AgentTaskStatus struct {}	Namespace string `json:"namespace"`	Name      string `json:"name"`	Kind      string `json:"kind"`type ResourceTarget struct {)	ActionPatchResource AgentAction = "patch"	ActionRollback      AgentAction = "rollback"	ActionDeploy        AgentAction = "deploy"	ActionUpdateConfig  AgentAction = "update-config"	ActionRestart       AgentAction = "restart"	ActionScale         AgentAction = "scale"const (type AgentAction string}	Payload map[string]interface{} `json:"payload,omitempty"`	// Payload contains action-specific data	Target ResourceTarget `json:"target"`	// Target is the target resource	Action AgentAction `json:"action"`	// Action is the Kubernetes action to perform	PoAToken string `json:"poaToken"`	// PoAToken is the Proof of Authorization token	AgentID string `json:"agentId"`	// AgentID is the SPIFFE ID of the requesting agenttype AgentTaskSpec struct {}	Status            AgentTaskStatus `json:"status,omitempty"`	Spec              AgentTaskSpec   `json:"spec"`	metav1.ObjectMeta `json:"metadata,omitempty"`	metav1.TypeMeta   `json:",inline"`type AgentTask struct {// AgentTask represents a task submitted by an AI agent)	ATBVersion = "v1alpha1"	ATBGroup   = "atb.siemens.com"const (// ATB CRD Group and Version)	"k8s.io/client-go/tools/clientcmd"	"k8s.io/client-go/rest"	"k8s.io/client-go/dynamic"	"k8s.io/apimachinery/pkg/watch"	"k8s.io/apimachinery/pkg/runtime/schema"	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"	"time"	"syscall"	"sync"	"os/signal"	"os"	"net/http"	"log"	"io"	"fmt"	"encoding/json"	"crypto/tls"	"context"import (package main*/  Agent -> AgentTask CR -> Operator -> ATB Broker -> (if allowed) -> K8s APIArchitecture:  3. Create AgentTask resources to trigger operator actions  2. Deploy operator: kubectl apply -f examples/k8s-operator/deploy/  1. Install CRDs: kubectl apply -f examples/k8s-operator/crds/Usage:This enables enterprise governance for AI agents managing Kubernetes workloads.The operator uses ATB to authorize agent actions before applying them to the cluster.ATB (Agent Trust Broker) for policy-controlled operations on Kubernetes resources.This example demonstrates how to build a Kubernetes operator that integrates withATB Kubernetes Operator Example/*